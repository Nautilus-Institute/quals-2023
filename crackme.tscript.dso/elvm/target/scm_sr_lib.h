/*
  Library for Scheme syntax-rules backend
*/

static char scm_sr_lib[] =
  ";;; CK machine\n"
  ";;; For detail, see http://okmij.org/ftp/Scheme/macros.html#ck-macros\n"
  "(define-syntax ck\n"
  "  (syntax-rules (quote)\n"
  "    ((_ () \'v) \'v)\n"
  "    ((_ (((op ...) ea ...) . s) \'v)\n"
  "     (ck s \"arg\" (op ... \'v) ea ...))\n"
  "    ((_ s \"arg\" (op va ...))\n"
  "     (op s va ...))\n"
  "    ((_ s \"arg\" (op ...) \'v ea1 ...)\n"
  "     (ck s \"arg\" (op ... \'v) ea1 ...))\n"
  "    ((_ s \"arg\" (op ...) ea ea1 ...)\n"
  "     (ck (((op ...) ea1 ...) . s) ea))\n"
  "    ((_ s (op ea ...))\n"
  "     (ck s \"arg\" (op) ea ...))))\n"
  "\n"
  ";;; Arighmetic Functions\n"
  "\n"
  ";; Natural numbers are represented in 24-bit little-endian 01 list\n"
  ";; -x is defined as ~x + 1\n"
  "\n"
  "(define-syntax zero!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s) (ck s \'(0 0 0 0 0 0 0 0\n"
  "		   0 0 0 0 0 0 0 0\n"
  "		   0 0 0 0 0 0 0 0)))))\n"
  "\n"
  "(define-syntax one!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s) (ck s \'(1 0 0 0 0 0 0 0\n"
  "		   0 0 0 0 0 0 0 0\n"
  "		   0 0 0 0 0 0 0 0)))))\n"
  "\n"
  "(define-syntax flip!\n"
  "  (syntax-rules (quote)\n"
  "    ;; optional\n"
  "    ((_ s x)\n"
  "     (flip! s x \'()))\n"
  "    ;; main\n"
  "    ((_ s \'() \'ys)\n"
  "     (ck s \'ys))\n"
  "    ((_ s \'(0 . xs) \'(y ...))\n"
  "     (flip! s \'xs \'(y ... 1)))\n"
  "    ((_ s \'(1 . xs) \'(y ...))\n"
  "     (flip! s \'xs \'(y ... 0)))))\n"
  "\n"
  "(define-syntax inc!\n"
  "  ;; (inc! x)   => x + 1\n"
  "  ;; (inc! x y) => y ++ (x + 1)\n"
  "  (syntax-rules (quote)\n"
  "    ;; optional\n"
  "    ((_ s x)\n"
  "     (inc! s x \'()))\n"
  "    ;; main\n"
  "    ((_ s \'() \'y) ;; ignore overflow\n"
  "     (ck s \'y))\n"
  "    ((_ s \'(0 . xs) \'(y ...))\n"
  "     (ck s \'(y ... 1 . xs)))\n"
  "    ((_ s \'(1 . xs) \'(y ...))\n"
  "     (inc! s \'xs \'(y ... 0)))))\n"
  "\n"
  "(define-syntax dec!\n"
  "  ;; (dec! x)   => x - 1\n"
  "  ;; (dec! x y) => y ++ (x - 1)\n"
  "  (syntax-rules (quote)\n"
  "    ;; optional\n"
  "    ((_ s x)\n"
  "     (dec! s x \'()))\n"
  "    ;; main\n"
  "    ((_ s \'() \'(y ...))\n"
  "     ;; ignore underflow\n"
  "     (ck s \'(y ...)))\n"
  "    ((_ s \'(0 . xs) \'(y ...))\n"
  "     (dec! s \'xs \'(y ... 1)))\n"
  "    ((_ s \'(1 . xs) \'(y ...))\n"
  "     (ck  s \'(y ... 0 . xs)))))\n"
  "\n"
  "(define-syntax add!\n"
  "  ;; (add! x y) => x + y\n"
  "  ;; (add! x y carry rest) => rest ++ (x + y + carry?1:0)\n"
  "  (syntax-rules (quote)\n"
  "    ;;; initialize\n"
  "    ((_ s x y) (add! s x y \'#f \'()))\n"
  "    ;;; corner case\n"
  "    ((_ s \'() \'() _ rest)\n"
  "     (ck s rest))\n"
  "    ;;; general case\n"
  "    ((_ s \'(0 . xs) \'(0 . ys) \'#f \'(r ...))\n"
  "     (add! s \'xs \'ys \'#f \'(r ... 0)))\n"
  "    ((_ s \'(1 . xs) \'(0 . ys) \'#f \'(r ...))\n"
  "     (add! s \'xs \'ys \'#f \'(r ... 1)))\n"
  "    ((_ s \'(0 . xs) \'(1 . ys) \'#f \'(r ...))\n"
  "     (add! s \'xs \'ys \'#f \'(r ... 1)))\n"
  "    ((_ s \'(1 . xs) \'(1 . ys) \'#f \'(r ...))\n"
  "     (add! s \'xs \'ys \'#t \'(r ... 0)))\n"
  "    ((_ s \'(0 . xs) \'(0 . ys) \'#t \'(r ...))\n"
  "     (add! s \'xs \'ys \'#f \'(r ... 1)))\n"
  "    ((_ s \'(1 . xs) \'(0 . ys) \'#t \'(r ...))\n"
  "     (add! s \'xs \'ys \'#t \'(r ... 0)))\n"
  "    ((_ s \'(0 . xs) \'(1 . ys) \'#t \'(r ...))\n"
  "     (add! s \'xs \'ys \'#t \'(r ... 0)))\n"
  "    ((_ s \'(1 . xs) \'(1 . ys) \'#t \'(r ...))\n"
  "     (add! s \'xs \'ys \'#t \'(r ... 1)))))\n"
  "\n"
  "(define-syntax sub!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s x y)\n"
  "     (ck s (add! x (inc! (flip! y)))))))\n"
  "\n"
  "(define-syntax cmp%!\n"
  "  ;; (cmp%! \'x \'y) => \'((x <= y) (x < y))\n"
  "  ;; assume that x and y are normalized\n"
  "  (syntax-rules (quote)\n"
  "    ;; optional arguemnt\n"
  "    ((_ s x y)\n"
  "     (cmp%! s x y \'\"=\"))\n"
  "    ;; corner case\n"
  "    ((_ s \'() \'() \'\"=\")\n"
  "     (ck s \'(1 0)))\n"
  "    ((_ s \'() \'() \'\"<\")\n"
  "     (ck s \'(1 1)))\n"
  "    ((_ s \'() \'() \'\">\")\n"
  "     (ck s \'(0 0)))\n"
  "    ;; recursion\n"
  "    ((_ s \'(0 . xs) \'(0 . ys) c)\n"
  "     (cmp%! s \'xs \'ys c))\n"
  "    ((_ s \'(1 . xs) \'(1 . ys) c)\n"
  "     (cmp%! s \'xs \'ys c))\n"
  "    ((_ s \'(0 . xs) \'(1 . ys) _)\n"
  "     (cmp%! s \'xs \'ys \'\"<\"))\n"
  "    ((_ s \'(1 . xs) \'(0 . ys) _)\n"
  "     (cmp%! s \'xs \'ys \'\">\"))))\n"
  "\n"
  "(define-syntax cmp!\n"
  "  ;; (cmp! op x y)\n"
  "  ;; => 1 (= \'(1)) when op x y satisfied\n"
  "  ;;    0 (= \'())  otherwise\n"
  "  ;; op := \"eq\" \"ne\" \"lt\" \"gt\" \"le\" \"ge\"\n"
  "  (syntax-rules (quote)\n"
  "    ;; wrap\n"
  "    ((_ s op x y)\n"
  "     (ck s (cmp! op (cmp%! x y))))\n"
  "    ;; main\n"
  "    ((_ s \'\"EQ\" \'(1 0)) (ck s (one!)))\n"
  "    ((_ s \'\"NE\" \'(0 _)) (ck s (one!)))\n"
  "    ((_ s \'\"NE\" \'(1 1)) (ck s (one!)))\n"
  "    ((_ s \'\"LT\" \'(_ 1)) (ck s (one!)))\n"
  "    ((_ s \'\"LE\" \'(1 _)) (ck s (one!)))\n"
  "    ((_ s \'\"GT\" \'(0 _)) (ck s (one!)))\n"
  "    ((_ s \'\"GE\" \'(_ 0)) (ck s (one!)))\n"
  "    ((_ s _ __)         (ck s (zero!)))))\n"
  "\n"
  "(define-syntax if!\n"
  "  ;; (if! bool then else)\n"
  "  ;; => else when bool == 0\n"
  "  ;;    then otherwise\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s \'(0 ...) \'then \'else) (ck s else))\n"
  "    ((_ s _   \'then \'else) (ck s then))))\n"
  "\n"
  ";;; Word utilities\n"
  "(define-syntax num-to-word!\n"
  "  ;; Coerce little-endian number to big-endian word\n"
  "  ;; (for num-to-addr and num-to-byte)\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s _ x \'()) (ck s x))\n"
  "    ((_ s \'(i . xs) \'(y ...) \'(0 z ...))\n"
  "     (num-to-word! s \'xs \'(i y ...) \'(z ...)))\n"
  "    ((_ s \'() \'(y ...) \'(0 z ...))\n"
  "     (num-to-word! s \'() \'(0 y ...) \'(z ...)))))\n"
  "\n"
  "(define-syntax num-to-addr!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s x) (num-to-word! s x \'()\n"
  "			   \'(0 0 0 0 0 0 0 0\n"
  "			     0 0 0 0 0 0 0 0\n"
  "			     0 0 0 0 0 0 0 0)))))\n"
  "\n"
  "(define-syntax num-to-byte!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s x) (num-to-word! s x \'() \'(0 0 0 0 0 0 0 0)))))\n"
  "\n"
  ";;; Memory Utilities\n"
  ";;\n"
  ";; Memory is represented as a binary tree. The address space is 24-bit,\n"
  ";; and an address is a 24-bit big-endian 01-list.\n"
  ";; To reduce memory consumption, empty binary tree can be represented\n"
  ";; just as an empty list.\n"
  "\n"
  ";;; Binary Lookup Table\n"
  ";; Constructor\n"
  "(define-syntax cons!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s \'x \'y) (ck s \'(x . y)))))\n"
  "\n"
  "(define-syntax list!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s) (ck s \'()))\n"
  "    ((_ s x y ...) (ck s (cons! x (list! y ...))))))\n"
  "\n"
  "(define-syntax lookup!\n"
  "  ;; (lookup! addr table) => table[addr]\n"
  "  ;; note that $addr is big endian\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s \'() d) (ck s d))\n"
  "    ((_ s \'(0 . r) \'(d . _)) (lookup! s \'r \'d))\n"
  "    ((_ s \'(1 . r) \'(_ . d)) (lookup! s \'r \'d))\n"
  "    ;; when memory is empty, return 0\n"
  "    ((_ s _ \'()) (ck s (zero!)))))\n"
  "\n"
  "(define-syntax update!\n"
  "  ;; (update! addr val table) => table[addr] := val\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s \'() val _) (ck s val))\n"
  "    ((_ s \'(0 . a) val \'(r . l)) (ck s (cons! (update! \'a val \'r) \'l)))\n"
  "    ((_ s \'(1 . a) val \'(r . l)) (ck s (cons! \'r (update! \'a val \'l))))\n"
  "    ;; when memory is empty, create a binary tree\n"
  "    ((_ s \'(0) val \'()) (ck s (cons! val (zero!))))\n"
  "    ((_ s \'(1) val \'()) (ck s (cons! (zero!) val)))\n"
  "    ((_ s \'(0 . a) val \'()) (ck s (cons! (update! \'a val \'()) \'())))\n"
  "    ((_ s \'(1 . a) val \'()) (ck s (cons! \'() (update! \'a val \'()))))))\n"
  "\n"
  ";;; VM consists of:\n"
  ";;; * execution state := \"load\" | \"exec\"\n"
  ";;; * PC : number\n"
  ";;; * six registers A, B, C, D, SP, and BP : number\n"
  ";;; * data memory : binary tree of number\n"
  ";;; * instruction memory : binary tree of instructions\n"
  ";;; * input stack : stack of bytes\n"
  ";;; * output stack : stack of bytes\n"
  "\n"
  ";;; Instruction format\n"
  ";;; Inst := (\"MOV\" dst src)\n"
  ";;;      |  (\"ADD\" dst src)\n"
  ";;;      |  (\"SUB\" dst src)\n"
  ";;;      |  (\"LOAD\" dst src)\n"
  ";;;      |  (\"STORE\" src dst)\n"
  ";;;      |  (\"PUTC\" src)\n"
  ";;;      |  (\"GETC\" dst)\n"
  ";;;      |  (\"EXIT\")\n"
  ";;;      |  (\"JCOND\" op jmp dst src)\n"
  ";;;      |  (\"JMP\" jmp)\n"
  ";;;      |  (\"CMP\" op dst src)\n"
  "\n"
  ";;; Virtual Machine\n"
  "(define-syntax eval-r!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s \'(a b c d sp bp)  \'\"A\") (ck s \'a))\n"
  "    ((_ s \'(a b c d sp bp)  \'\"B\") (ck s \'b))\n"
  "    ((_ s \'(a b c d sp bp)  \'\"C\") (ck s \'c))\n"
  "    ((_ s \'(a b c d sp bp)  \'\"D\") (ck s \'d))\n"
  "    ((_ s \'(a b c d sp bp) \'\"SP\") (ck s \'sp))\n"
  "    ((_ s \'(a b c d sp bp) \'\"BP\") (ck s \'bp))))\n"
  "\n"
  "(define-syntax eval-ir!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s reg \'(\"REG\" r)) (eval-r! s reg \'r))\n"
  "    ((_ s reg \'(\"IMM\" i)) (ck s \'i))))\n"
  "\n"
  "(define-syntax update-reg!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s \'(a b c d sp bp) \'\"A\"  \'v) (ck s \'(v b c d sp bp)))\n"
  "    ((_ s \'(a b c d sp bp) \'\"B\"  \'v) (ck s \'(a v c d sp bp)))\n"
  "    ((_ s \'(a b c d sp bp) \'\"C\"  \'v) (ck s \'(a b v d sp bp)))\n"
  "    ((_ s \'(a b c d sp bp) \'\"D\"  \'v) (ck s \'(a b c v sp bp)))\n"
  "    ((_ s \'(a b c d sp bp) \'\"SP\" \'v) (ck s \'(a b c d v  bp)))\n"
  "    ((_ s \'(a b c d sp bp) \'\"BP\" \'v) (ck s \'(a b c d sp v )))))\n"
  "\n"
  "(define-syntax write!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s \'(o ...) \'v) (ck s \'(o ... v)))))\n"
  "\n"
  "(define-syntax peek!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s \'(x _ ...)) (ck s \'x))\n"
  "    ((_ s \'()) (ck s (zero!)))))\n"
  "\n"
  "(define-syntax pop!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s \'(_ x ...)) (ck s \'(x ...)))\n"
  "    ((_ s \'()) (ck s \'()))))\n"
  "\n"
  "(define-syntax run-vm!\n"
  "  (syntax-rules (quote)\n"
  "    ;; load instruction\n"
  "    ((_ s \'\"load\" pc reg dmem imem i o)\n"
  "     (ck s (run-vm! \'\"exec\" (lookup! (num-to-addr! pc) imem)\n"
  "		    pc reg dmem imem i o)))\n"
  "\n"
  "    ;; execute instruction\n"
  "    ((_ s \'\"exec\" \'() pc reg dmem imem i o)\n"
  "     (ck s (run-vm! \'\"load\"  (inc! pc) reg dmem imem i o)))\n"
  "\n"
  "    ((_ s \'\"exec\" \'((\"MOV\" dst src) . rest) pc reg dmem imem i o)\n"
  "     (ck s (run-vm! \'\"exec\" \'rest\n"
  "		    pc (update-reg! reg \'dst (eval-ir! reg \'src))\n"
  "		    dmem imem i o)))\n"
  "\n"
  "    ((_ s \'\"exec\" \'((\"ADD\" dst src) . rest) pc reg dmem imem i o)\n"
  "     (ck s (run-vm! \'\"exec\" \'rest\n"
  "		    pc\n"
  "		    (update-reg! reg \'dst (add! (eval-r! reg \'dst)\n"
  "						(eval-ir! reg \'src)))\n"
  "		    dmem imem i o)))\n"
  "\n"
  "    ((_ s \'\"exec\" \'((\"SUB\" dst src) . rest) pc reg dmem imem i o)\n"
  "     (ck s (run-vm! \'\"exec\" \'rest\n"
  "		    pc\n"
  "		    (update-reg! reg \'dst (sub! (eval-r! reg \'dst)\n"
  "						(eval-ir! reg \'src)))\n"
  "		    dmem imem i o)))\n"
  "\n"
  "    ((_ s \'\"exec\" \'((\"LOAD\" dst src) . rest) pc reg dmem imem i o)\n"
  "     (ck s (run-vm! \'\"exec\" \'rest\n"
  "		    pc\n"
  "		    (update-reg! reg \'dst\n"
  "				 (lookup! (num-to-addr! (eval-ir! reg \'src))\n"
  "					  dmem))\n"
  "		    dmem imem i o)))\n"
  "\n"
  "    ((_ s \'\"exec\" \'((\"STORE\" src dst) . rest) pc reg dmem imem i o)\n"
  "     (ck s (run-vm! \'\"exec\" \'rest\n"
  "		    pc reg\n"
  "		    (update! (num-to-addr! (eval-ir! reg \'dst))\n"
  "			     (eval-r! reg \'src) dmem)\n"
  "		    imem i o)))\n"
  "\n"
  "    ((_ s \'\"exec\" \'((\"PUTC\" src) . rest) pc reg dmem imem i o)\n"
  "     (ck s (run-vm! \'\"exec\" \'rest\n"
  "		    pc reg dmem imem i\n"
  "		    (write! o (num-to-byte! (eval-ir! reg \'src))))))\n"
  "\n"
  "    ((_ s \'\"exec\" \'((\"GETC\" dst) . rest) pc reg dmem imem i o)\n"
  "     (ck s (run-vm! \'\"exec\" \'rest\n"
  "		    pc\n"
  "		    (update-reg! reg \'dst (peek! i)) dmem imem\n"
  "		    (pop! i) o)))\n"
  "\n"
  "    ((_ s \'\"exec\" \'((\"EXIT\") . _) pc reg dmem imem i o)\n"
  "     ;; When the vm reach EXIT, it stops execution.\n"
  "     ;; Therefore it does not call ck.\n"
  "     (emit! o))\n"
  "\n"
  "    ((_ s \'\"exec\" \'((\"JCOND\" op jmp dst src) . rest) pc reg dmem imem i o)\n"
  "     (ck s (if! (cmp! \'op (eval-r! reg \'dst) (eval-ir! reg \'src))\n"
  "		\'(run-vm! \'\"load\" (eval-ir! reg \'jmp) reg dmem imem i o)\n"
  "		\'(run-vm! \'\"exec\" \'rest pc reg dmem imem i o))))\n"
  "\n"
  "    ((_ s \'\"exec\" \'((\"JMP\" jmp) . _) pc reg dmem imem i o)\n"
  "     (ck s (run-vm! \'\"load\" (eval-ir! reg \'jmp) reg dmem imem i o)))\n"
  "\n"
  "    ((_ s \'\"exec\" \'((\"CMP\" op dst src) . rest) pc reg dmem imem i o)\n"
  "     (ck s (run-vm! \'\"exec\" \'rest\n"
  "		    pc\n"
  "		    (update-reg! reg \'dst (cmp! \'op (eval-r! reg \'dst)\n"
  "						(eval-ir! reg \'src)))\n"
  "		    dmem imem i o)))))\n"
  "\n"
  ";;; Emitter\n"
  "(define (fold fn l i)\n"
  "  (if (null? l)\n"
  "      i\n"
  "      (fold fn (cdr l) (fn (car l) i))))\n"
  "\n"
  "(define (blist->num blist)\n"
  "  (fold (lambda (x i) (+ x (* 2 i))) blist 0))\n"
  "\n"
  "(define-syntax emit!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ o)\n"
  "     (for-each (lambda (blist) (write-char (integer->char\n"
  "					    (blist->num blist))))\n"
  "	       o))))\n"
  "\n"
  ";;; initial register\n"
  "(define init-reg!\n"
  "  (syntax-rules (quote)\n"
  "    ((_ s)\n"
  "     (ck s (list! (zero!) (zero!) (zero!) (zero!) (zero!) (zero!))))))\n";
