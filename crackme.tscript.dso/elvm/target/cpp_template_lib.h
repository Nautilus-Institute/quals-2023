/*
  Library for C++ Template Metaprogramming backend

  Original Version:
  https://gist.github.com/kw-udon/6248197ec8fdc681b63e4cb8271fac56
*/

static char cpp_template_lib[] =
  "// Library for ELVM's C++ Template Metaprogramming backend\n"
 "\n"
  "// Input Buffer\n"
  "constexpr static const char* input =\n"
  "#   include \"input.txt\"\n"
  ";\n"
  "\n"
  "// Memory Size\n"
  "const int MEM_SIZE = 1 << 16;\n"
  "\n"
  "// Data Structures\n"
  "\n"
  "template <int n>  struct Int {static const int  val = n;};\n"
  "template <bool b> struct Bool{static const bool val = b;};\n"
  "\n"
  "// List\n"
  "struct Nil { typedef Nil head; typedef Nil tail; };\n"
  "template <typename Head, typename Tail/*=Nil*/>\n"
  "struct Pair { typedef Head head; typedef Tail tail; };\n"
  "\n"
  "template<typename l>\n"
  "struct is_nil : Bool<false> {};\n"
  "template<>\n"
  "struct is_nil<Nil> : Bool<true> {};\n"
  "\n"
  "template <typename head, typename tail>\n"
  "struct cons : Pair<head, tail> {};\n"
  "\n"
  "template <typename list, int n>\n"
  "struct get_at : get_at<typename list::tail, n-1> {};\n"
  "template <typename list>\n"
  "struct get_at<list, 0> : list::head {};\n"
  "\n"
  "template <typename list, int n, int v>\n"
  "struct set_at : cons<typename list::head, set_at<typename list::tail, n - 1, v>> {};\n"
  "template <typename list, int v>\n"
  "struct set_at<list, 0, v> : cons<Int<v>, typename list::tail> {};\n"
  "\n"
  "template <int n>\n"
  "struct init_list_aux {\n"
  "  typedef typename init_list_aux<n-1>::result tail;\n"
  "  typedef cons<Int<0>, tail> result;\n"
  "};\n"
  "template <>\n"
  "struct init_list_aux<0> {\n"
  "  typedef Nil result;\n"
  "};\n"
  "template <int n>\n"
  "struct init_list : init_list_aux<n>::result {};\n"
  "\n"
  "//  Binary Tree (for Memory)\n"
  "template <typename node_v, typename lnode, typename rnode>\n"
  "struct Node {\n"
  "  typedef node_v value;\n"
  "  typedef lnode left;\n"
  "  typedef rnode right;\n"
  "  static const bool is_leaf = is_nil<lnode>::val && is_nil<rnode>::val;\n"
  "};\n"
  "template <typename v>\n"
  "struct Leaf : Node<v, Nil, Nil> {};\n"
  "\n"
  "template <int depth>\n"
  "struct mk_tree {\n"
  "  typedef Int<depth> value;\n"
  "  typedef mk_tree<depth-1> left;\n"
  "  typedef mk_tree<depth-1> right;\n"
  "};\n"
  "template <>\n"
  "struct mk_tree<0> : Leaf<Int<0>> {};\n"
  "\n"
  "template <typename tree, int flg>\n"
  "struct get_child : tree::left {};\n"
  "template <typename tree>\n"
  "struct get_child<tree, 1> : tree::right {};\n"
  "template <typename tree, typename child, int flg>\n"
  "struct update_child : tree { typedef child left; };\n"
  "template <typename tree, typename child>\n"
  "struct update_child<tree, child, 1> : tree {typedef child right;};\n"
  "\n"
  "\n"
  "// Memory\n"
  "\n"
  "constexpr int const_log2(int x) {\n"
  "  return x < 2 ? x : 1 + const_log2(x >> 1);\n"
  "}\n"
  "template <int mem_size>\n"
  "struct init_memory {\n"
  "  static const int depth = const_log2(mem_size); // memory size == 2^d\n"
  "  typedef mk_tree<depth> tree;\n"
  "};\n"
  "\n"
  "// Memory Access\n"
  "// Load\n"
  "template <typename tree, int depth, int idx>\n"
  "struct load_value_aux {\n"
  "  static const int flg = (idx >> (depth-1)) & 1;\n"
  "  typedef get_child<tree, flg> child;\n"
  "  typedef typename load_value_aux<child, depth-1, idx>::result result;\n"
  "};\n"
  "\n"
  "template <typename tree, int idx>\n"
  "struct load_value_aux<tree, 0, idx> {\n"
  "  typedef typename tree::value result;\n"
  "};\n"
  "\n"
  "template <typename memory, int idx>\n"
  "struct load_value : load_value_aux<typename memory::tree, memory::depth, idx & (MEM_SIZE - 1)>::result {};\n"
  "\n"
  "// Store\n"
  "template <typename tree, int depth, int idx, int new_v>\n"
  "struct store_value_aux {\n"
  "  static const int flg = (idx >> (depth-1)) & 1;\n"
  "  typedef get_child<tree, flg> child;\n"
  "  typedef typename store_value_aux<child, depth-1, idx, new_v>::result new_child;\n"
  "  typedef update_child<tree, new_child, flg> result;\n"
  "};\n"
  "template <typename tree, int idx, int new_v>\n"
  "struct store_value_aux<tree, 0, idx, new_v> {\n"
  "  typedef Leaf<Int<new_v>> result;\n"
  "};\n"
  "\n"
  "template <typename memory, int idx, int new_v>\n"
  "struct store_value : memory {\n"
  "  typedef typename store_value_aux<typename memory::tree, memory::depth, idx & (MEM_SIZE - 1), new_v>::result tree;\n"
  "};\n"
  "\n"
  "// Registers\n"
  "template <int PC>\n"
  "struct init_regs {\n"
  "  static const int a = 0;\n"
  "  static const int b = 0;\n"
  "  static const int c = 0;\n"
  "  static const int d = 0;\n"
  "  static const int sp = 0;\n"
  "  static const int bp = 0;\n"
  "  static const int pc = PC;\n"
  "  static const bool exit_flag = false;\n"
  "  static const int input_cur = 0;\n"
  "};\n"
  "\n"
  "template <typename regs, int src_reg>\n"
  "struct reg_val {};\n"
  "template <typename regs>\n"
  "struct reg_val<regs, 0> { static const int val = regs::a;};\n"
  "template <typename regs>\n"
  "struct reg_val<regs, 1> { static const int val = regs::b;};\n"
  "template <typename regs>\n"
  "struct reg_val<regs, 2> { static const int val = regs::c;};\n"
  "template <typename regs>\n"
  "struct reg_val<regs, 3> { static const int val = regs::d;};\n"
  "template <typename regs>\n"
  "struct reg_val<regs, 4> { static const int val = regs::sp;};\n"
  "template <typename regs>\n"
  "struct reg_val<regs, 5> { static const int val = regs::bp;};\n"
  "\n"
  "\n"
  "// Environment (Tuple of Registers, Memory and Buffer)\n"
  "template <typename Regs, typename Mem, typename Buf>\n"
  "struct make_env {\n"
  "  typedef Regs regs;\n"
  "  typedef Mem mem;\n"
  "  typedef Buf buf;\n"
  "};\n"
  "\n"
  "template <typename regs, int PC>\n"
  "struct update_pc : regs {static const int pc = PC;};\n"
  "template <typename regs>\n"
  "struct inc_input_cur : regs {static const int input_cur = regs::input_cur + (input[regs::input_cur] ? 1 : 0);};\n"
  "template <typename regs, typename mem, typename buf>\n"
  "struct inc_pc : make_env<update_pc<regs, 1 + regs::pc>, mem, buf> {};\n"
  "\n"
  "\n"
  "// Functions for Each Instruction\n"
  "\n"
  "// MOV\n"
  "template <typename r, int dst_reg, int imm>\n"
  "struct mov_imm_aux : r {};\n"
  "template <typename r, int imm>\n"
  "struct mov_imm_aux<r, 0, imm> : r {static const int a = imm;};\n"
  "template <typename r, int imm>\n"
  "struct mov_imm_aux<r, 1, imm> : r {static const int b = imm;};\n"
  "template <typename r, int imm>\n"
  "struct mov_imm_aux<r, 2, imm> : r {static const int c = imm;};\n"
  "template <typename r, int imm>\n"
  "struct mov_imm_aux<r, 3, imm> : r {static const int d = imm;};\n"
  "template <typename r, int imm>\n"
  "struct mov_imm_aux<r, 4, imm> : r {static const int sp = imm;};\n"
  "template <typename r, int imm>\n"
  "struct mov_imm_aux<r, 5, imm> : r {static const int bp = imm;};\n"
  "\n"
  "template <typename regs, int dst_reg, int imm>\n"
  "struct mov_imm : mov_imm_aux<regs, dst_reg, imm> {};\n"
  "template <typename regs, int dst_reg, int src_reg>\n"
  "struct mov_reg : mov_imm_aux<regs, dst_reg, reg_val<regs, src_reg>::val> {};\n"
  "\n"
  "// ADD, SUB\n"
  "template <typename regs, int dst_reg, int imm>\n"
  "struct add_aux {\n"
  "  static const int dst_val = reg_val<regs, dst_reg>::val;\n"
  "  typedef mov_imm<regs, dst_reg, (dst_val + imm) & (MEM_SIZE - 1)> result;\n"
  "};\n"
  "template <typename regs, int dst_reg, int imm>\n"
  "struct add_imm : add_aux<regs, dst_reg, imm>::result {};\n"
  "template <typename regs, int dst_reg, int src_reg>\n"
  "struct add_reg : add_aux<regs, dst_reg, reg_val<regs, src_reg>::val>::result {};\n"
  "template <typename regs, int dst_reg, int imm>\n"
  "struct sub_imm : add_aux<regs, dst_reg, -imm>::result {};\n"
  "template <typename regs, int dst_reg, int src_reg>\n"
  "struct sub_reg : add_aux<regs, dst_reg, -reg_val<regs, src_reg>::val>::result {};\n"
  "\n"
  "// LOAD\n"
  "template <typename mem, int addr>\n"
  "struct load_aux : load_value<mem, addr> {};\n"
  "\n"
  "template <typename regs, typename mem, int dst_reg, int addr>\n"
  "struct load_imm : mov_imm<regs, dst_reg, load_aux<mem, addr>::val> {};\n"
  "template <typename regs, typename mem, int dst_reg, int src_reg>\n"
  "struct load_reg : load_imm<regs, mem, dst_reg, reg_val<regs, src_reg>::val> {};\n"
  "\n"
  "// STORE\n"
  "template <typename regs, typename mem, int src_reg, int addr>\n"
  "struct store_aux {\n"
  "  typedef reg_val<regs, src_reg> data;\n"
  "  typedef store_value<mem, addr, data::val> result;\n"
  "};\n"
  "\n"
  "template <typename regs, typename mem, int src_reg, int addr>\n"
  "struct store_imm : store_aux<regs, mem, src_reg, addr>::result {};\n"
  "template <typename regs, typename mem, int src_reg, int dst_reg>\n"
  "struct store_reg : store_imm<regs, mem, src_reg, reg_val<regs, dst_reg>::val> {};\n"
  "\n"
  "// PUTC\n"
  "template <typename regs, typename buffer, int imm>\n"
  "struct putc_aux {\n"
  "  typedef cons<Int<imm>, buffer> result;\n"
  "};\n"
  "template <typename regs, typename buffer, int imm>\n"
  "struct putc_imm : putc_aux<regs, buffer, imm>::result {};\n"
  "template <typename regs, typename buffer, int src_reg>\n"
  "struct putc_reg : putc_imm<regs, buffer, reg_val<regs, src_reg>::val> {};\n"
  "\n"
  "// GETC\n"
  "template <typename regs, int dst_reg>\n"
  "struct getc_aux {\n"
  "  static const int read_val = input[regs::input_cur];\n"
  "  typedef inc_input_cur<regs> regs2;\n"
  "  typedef mov_imm<regs2, dst_reg, read_val & (MEM_SIZE - 1)> result;\n"
  "};\n"
  "template <typename regs, int dst_reg>\n"
  "struct getc_reg : getc_aux<regs, dst_reg>::result {};\n"
  "\n"
  "\n"
  "// EXIT\n"
  "template <typename regs>\n"
  "struct exit_inst : regs {\n"
  "  static const int pc = 1000000;\n"
  "  static const bool exit_flag = true;\n"
  "};\n"
  "\n"
  "// JMP\n"
  "template <typename regs, int label, int cmp_flg>\n"
  "struct jmp_aux : update_pc<regs, label>{};\n"
  "template <typename regs, int label>\n"
  "struct jmp_aux<regs, label, 0> : regs {};\n"
  "\n"
  "template <typename regs, int imm>\n"
  "struct jmp_imm : jmp_aux<regs, imm - 1, 1> {};\n"
  "template <typename regs, int reg>\n"
  "struct jmp_reg : jmp_aux<regs, reg_val<regs, reg>::val - 1, 1> {};\n"
  "\n"
  "// CMP\n"
  "template <typename regs, int reg0, int imm>\n"
  "struct eq_imm {\n"
  "  static const int reg_v = reg_val<regs, reg0>::val;\n"
  "  static const bool result = (reg_v == imm);\n"
  "};\n"
  "\n"
  "template <typename regs, int reg, int imm, int op>\n"
  "struct cmp_op_imm {\n"
  "  static const int v = reg_val<regs, reg>::val;\n"
  "  static const int result =\n"
  "    op == 0 ? (v == imm) :\n"
  "    op == 1 ? (v != imm) :\n"
  "    op == 2 ? (v <  imm) :\n"
  "    op == 3 ? (v >  imm) :\n"
  "    op == 4 ? (v <= imm) :\n"
  "    op == 5 ? (v >= imm) :\n"
  "    1;\n"
  "};\n"
  "\n"
  "template <typename regs, int reg1, int reg2, int op>\n"
  "struct cmp_op_reg : cmp_op_imm<regs, reg1, reg_val<regs, reg2>::val, op> {};\n"
  "\n"
  "template <typename regs, int dst_reg, int imm, int op>\n"
  "struct cmp_imm : mov_imm<regs, dst_reg, cmp_op_imm<regs, dst_reg, imm, op>::result> {};\n"
  "template <typename regs, int dst_reg, int src_reg, int op>\n"
  "struct cmp_reg : mov_imm<regs, dst_reg, cmp_op_reg<regs, dst_reg, src_reg, op>::result> {};\n"
  "\n"
  "// JCMP\n"
  "template <typename regs, int label, int src_reg, int imm, int op>\n"
  "struct jcmp_imm : jmp_aux<regs, label, cmp_op_imm<regs, src_reg, imm, op>::result> {};\n"
  "template <typename regs, int label, int src_reg1, int src_reg2, int op>\n"
  "struct jcmp_reg : jmp_aux<regs, label, cmp_op_reg<regs, src_reg1, src_reg2, op>::result> {};\n"
  "\n"
  "// print_buffer\n"
  "template <typename list>\n"
  "struct print_buffer_aux {\n"
  "  static inline void run () {\n"
  "    print_buffer_aux<typename list::tail>::run();\n"
  "    putchar(list::head::val);\n"
  "  }\n"
  "};\n"
  "template <>\n"
  "struct print_buffer_aux<Nil> { static inline void run () {}};\n"
  "template <typename list>\n"
  "struct print_buffer : print_buffer_aux<list> {};\n"
  "\n"
  "// Library ends here\n";
